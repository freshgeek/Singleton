package top.design.singleton;


/***
 * 
 * 和第三种差不多
 * 只不过放在了静态代码块中
 * 
 * 此处说明下类加载所有属性 静态 方法 加载顺序
加载过程：

1、JVM会先去方法区中找有没有相应类的.class存在。
如果有，就直接使用；
如果没有，则把相关类的.clss加载到方法区。

2、在.class加载到方法区时，先加载父类再加载子类；
先加载静态内容，再加载非静态内容

3、加载静态内容：

把.class中的所有静态内容加载到方法区下的静态区域内
静态内容加载完成之后，对所有的静态变量进行默认初始化
所有的静态变量默认初始化完成之后，再进行显式初始化
当静态区域下的所有静态变量显式初始化完后，执行静态代码块
4、加载非静态内容：把.class中的所有非静态变量及非静态代码块加载到方法区下的非静态区域内。

5、执行完之后，整个类的加载就完成了。

对于静态方法和非静态方法都是被动调用，即系统不会自动调用执行，
所以用户没有调用时都不执行，主要区别在于静态方法可以直接用类名直接调用（实例化对象也可以），
而非静态方法只能先实例化对象后才能调用。

二、对象的创建过程
1、new一个对象时，在堆内存中开辟一块空间。

2、给开辟的空间分配一个地址。

3、把对象的所有非静态成员加载到所开辟的空间下。

4、所有的非静态成员加载完成之后，对所有非静态成员变量进行默认初始化。

5、所有非静态成员变量默认初始化完成之后，调用构造函数。

6、在构造函数入栈执行时，分为两部分：先执行构造函数中的隐式三步，再执行构造函数中书写的代码。

隐式三步：
   ①执行super()语句
 
   ②显示初始化(对开辟空间下的所有非静态成员变量进行) 

   ③执行构造代码块
7、在整个构造函数执行完并弹栈后，把空间分配的地址赋给引用对象。


 * 
* @Description:TODO

* @author:   chen.chao

* @time:2018年10月22日 下午4:15:30
 */
public class Singleton4 {

	private static Singleton4 instance = null;
	static{
		instance = new Singleton4();
	}
	private Singleton4() {
	}
	

	public static Singleton4 getInstance() {
		return instance;
	}

}